/**
 * @title DAO
 * @notice This contract implements a decentralized autonomous organization (DAO) where members can create and vote on proposals.
 */
@compiler >= 6

include "String.aes"
include "List.aes"
include "Pair.aes"


contract DAO = 

    /**
     * @dev Structure to store the state of the DAO.
     */
    record state = {
        name: string,               // The name of the DAO
        id: string,
        description: string,        // A brief description of the DAO
        image: string,              // URL of the DAO's image
        socials: list(string),      // List of social media links associated with the DAO
        votingTime: int,            // Duration of the voting period for proposals (in milliseconds)
        quorum: int,                // Percentage of members required for a proposal to be considered valid
        proposals: map(int, proposal),  // Mapping of proposal IDs to their respective details
        totalProposals: int,        // Total number of proposals created
        totalVotes: int,            // Total number of votes cast
        members: list(address),     // List of addresses representing members of the DAO
        activities: map(address, userActivities)}  // Mapping of member addresses to their respective voting activities

    /**
     * @dev Structure to represent a proposal.
     */
    record proposal = {
        id: int,                    // Unique identifier for the proposal
        proposer: address,          // Address of the member who proposed the action
        proposalType: string,       // Type of proposal (e.g., addMember, removeMember, setQuorum, setVotingTime)
        description: string,        // Description of the proposal
        value: int,                 // Value associated with the proposal (if applicable)
        target: address,            // Target address affected by the proposal (if applicable)
        startTime: int,              // Timestamp indicating the start of the voting period for the proposal
        endTime: int,               // Timestamp indicating the end of the voting period for the proposal
        votesFor: int,              // Number of votes in favor of the proposal
        votesAgainst: int,          // Number of votes against the proposal
        isExecuted: bool,           // Flag indicating whether the proposal has been executed
        hasVoted: map(address, bool)}  // Mapping of member addresses to their vote status for the proposal

    record formattedProposal = {
        id: int,                    // Unique identifier for the proposal
        daoName: string,
        daoId: string,
        proposer: address,          // Address of the member who proposed the action
        proposalType: string,       // Type of proposal (e.g., addMember, removeMember, setQuorum, setVotingTime)
        description: string,        // Description of the proposal
        value: int,                 // Value associated with the proposal (if applicable)
        target: address,            // Target address affected by the proposal (if applicable)
        startTime: int,              // Timestamp indicating the start of the voting period for the proposal
        endTime: int,               // Timestamp indicating the end of the voting period for the proposal
        votesFor: int,              // Number of votes in favor of the proposal
        votesAgainst: int,          // Number of votes against the proposal
        isExecuted: bool,           // Flag indicating whether the proposal has been executed
        voters: list(address)}  // Mapping of member addresses to their vote status for the proposal


    record userActivities = {
        address: address,
        voteCasted: int,
        proposalsCreated: int,
        proposalsExecuted: int}

    /**
     * @dev Structure to represent information about the DAO.
     */
    record info = {
        name: string,               // The name of the DAO
        id: string,                 // Unique identifier for the DAO
        description: string,        // A brief description of the DAO
        contractAddress: DAO,       // Address of the DAO contract
        account: address,           // Address of the DAO contract
        image: string,              // URL of the DAO's image
        socials: list(string),  // List of social media links associated with the DAO
        quorum: int,                // Percentage of members required for a proposal to be considered valid
        votingTime: int,            // Duration of the voting period for proposals (in milliseconds)
        members: list(address),     // List of addresses representing members of the DAO
        totalProposals: int,        // Total number of proposals created
        totalVotes: int,            // Total number of votes cast
        activeProposals: int}       // Number of active proposals (i.e., proposals with ongoing voting)


    /**
     * @notice Initializes the DAO with the provided parameters.
     * @param _name The name of the DAO.
     * @param _description A brief description of the DAO.
     * @param _image URL of the DAO's image.
     * @param _socials List of social media links associated with the DAO.
     * @param _creator Address of the creator of the DAO.
     * @param _initialMembers List of addresses representing initial members of the DAO.
     * @return The initial state of the DAO.
     */
    stateful entrypoint init(_name: string, _id: string, _description: string, _image: string, _socials: list(string), _creator: address, _initialMembers: list(address), _votingTime: int, _quorum: int): state = 
        require(_quorum > 0 && _quorum =< 100, "Quorum must be between 0 and 100")
        {
            name = _name,
            id = _id,
            description = _description,
            image = _image,
            socials = _socials,
            votingTime = _votingTime,
            quorum = _quorum,
            proposals = {},
            totalProposals = 0,
            totalVotes = 0,
            members = _creator :: _initialMembers,
            activities = {}}

    /**
     * @notice Retrieves information about the DAO.
     * @return Information about the DAO.
     */
    public entrypoint getInfo(): info = 
        {
            name = state.name,
            id = state.id,
            description = state.description,
            contractAddress = Address.to_contract(Contract.address): DAO,
            account = Contract.address,
            image = state.image,
            socials = state.socials,
            quorum = state.quorum,
            votingTime = state.votingTime,
            members = state.members,
            totalProposals = state.totalProposals,
            totalVotes = state.totalVotes,
            activeProposals = List.length(List.filter((x) => Pair.snd(x).endTime > Chain.timestamp, Map.to_list(state.proposals)))}

    /**
     * @notice Retrieves all proposals.
     * @return List of all proposals.
     */
    public entrypoint getProposals(): list(formattedProposal) = 
        List.map((x) => formatProposal(Pair.snd(x)), Map.to_list(state.proposals))

    function formatProposal(_proposal: proposal): formattedProposal = 
        {
            description = _proposal.description,
            id = _proposal.id,
            value = _proposal.value,
            target = _proposal.target,
            startTime = _proposal.startTime,
            endTime = _proposal.endTime,
            proposer = _proposal.proposer,
            proposalType = _proposal.proposalType,
            votesFor = _proposal.votesFor,
            votesAgainst = _proposal.votesAgainst,
            isExecuted = _proposal.isExecuted,
            voters = List.map((x) => Pair.fst(x), Map.to_list(_proposal.hasVoted)),
            daoName = state.name,
            daoId = state.id}
    /**
     * @notice Retrieves active proposals.
     * @return List of active proposals.
     */
    public entrypoint getActiveProposals(): list(formattedProposal) = 
        List.filter((p) => p.endTime > Chain.timestamp, getProposals())

    /**
     * @notice Retrieves details of a specific proposal.
     * @param id The ID of the proposal.
     * @return Details of the specified proposal.
     */
    public entrypoint getProposal(id: int): formattedProposal = 
        switch(Map.lookup(id, state.proposals))
            None => abort("Invalid proposal id")
            Some(p) => formatProposal(p)

    /**
     * @notice Checks if an address is a member of the DAO.
     * @param account The address to check.
     * @return True if the address is a member, otherwise false.
     */
    public entrypoint isMember(account: address): bool =
        List.contains(account, state.members)

    public entrypoint getMemberActivities(account: address): userActivities =
        Map.lookup_default(account, state.activities, { address = account, voteCasted = 0, proposalsCreated = 0, proposalsExecuted = 0})

    public entrypoint getAllMembersActivities(): list(userActivities) =
        List.map((x) => Pair.snd(x), Map.to_list(state.activities))

    /**
     * @notice Creates a new proposal.
     * @param _proposalType Type of proposal.
     * @param _description Description of the proposal.
     * @param _value Value associated with the proposal.
     * @param _target Target address affected by the proposal.
     * @return The ID of the newly created proposal.
     */
    public stateful entrypoint createProposal(_proposalType: string, _description: string, _value: int, _target: address) = 
        require(isMember(Call.caller), "You're not a member of this DAO")
        let proposalId : int = state.totalProposals
        let newProposal : proposal = {
            id = proposalId,
            proposer = Call.caller,
            proposalType = _proposalType,
            description = _description,
            value = _value,
            target= _target,
            startTime = Chain.timestamp,
            endTime = Chain.timestamp + state.votingTime,
            votesFor = 0,
            votesAgainst = 0,
            isExecuted = false,
            hasVoted = {}}
        put(state{proposals[proposalId] = newProposal, totalProposals = proposalId + 1})
        let activities : userActivities = Map.lookup_default(Call.caller, state.activities, {address = Call.caller, proposalsCreated = 0, proposalsExecuted = 0, voteCasted = 0})
        put(state{activities[Call.caller] = activities{proposalsCreated = activities.proposalsCreated + 1}})
        newProposal

    /**
     * @notice Casts a vote in favor of a proposal.
     * @param proposalId The ID of the proposal to vote for.
     */
    public stateful entrypoint voteFor(proposalId: int) = 
        require(isMember(Call.caller), "You're not a member of this DAO")
        require(proposalId < state.totalProposals, "Invalid proposal id")
        let proposal = state.proposals[proposalId]
        require(!Map.lookup_default(Call.caller, proposal.hasVoted, false), "You've already voted!")
        require(Chain.timestamp < proposal.endTime, "Proposal has ended!")

        let updatedProposal = proposal{votesFor @ v = v + 1}
        put(state{proposals[proposalId] = updatedProposal, totalVotes = state.totalVotes + 1})
        put(state{proposals[proposalId].hasVoted[Call.caller] = true})
        let activities : userActivities = Map.lookup_default(Call.caller, state.activities, {address = Call.caller, proposalsCreated = 0, proposalsExecuted = 0, voteCasted = 0})
        put(state{activities[Call.caller] = activities{proposalsCreated = activities.voteCasted + 1}})
        updatedProposal

    /**
     * @notice Casts a vote against a proposal.
     * @param proposalId The ID of the proposal to vote against.
     */
    public stateful entrypoint voteAgainst(proposalId: int) = 
        require(isMember(Call.caller), "You're not a member of this DAO")
        require(proposalId < state.totalProposals, "Invalid proposal id")
        let proposal = state.proposals[proposalId]
        require(!Map.lookup_default(Call.caller, proposal.hasVoted, false), "You've already voted!")
        require(Chain.timestamp < proposal.endTime, "Proposal has ended!")
        let updatedProposal = proposal{votesFor @ v = v - 1}
        put(state{proposals[proposalId] = updatedProposal, totalVotes = state.totalVotes + 1})
        put(state{proposals[proposalId].hasVoted[Call.caller] = true})
        let activities : userActivities = Map.lookup_default(Call.caller, state.activities, {address = Call.caller, proposalsCreated = 0, proposalsExecuted = 0, voteCasted = 0})
        put(state{activities[Call.caller] = activities{proposalsCreated = activities.voteCasted + 1}})
        updatedProposal

    /**
     * @notice Executes a proposal if conditions are met.
     * @param proposalId The ID of the proposal to execute.
     */
    public stateful entrypoint executeProposal(proposalId: int) = 
        require(isMember(Call.caller), "You're not a member of this DAO")
        let proposal = Map.lookup_default(proposalId, state.proposals, abort("Invalid proposal id"))
        require(Chain.timestamp > proposal.endTime, "Proposal has not ended!")
        require(!proposal.isExecuted, "Proposal already executed")
        let votesTotal = proposal.votesFor + proposal.votesAgainst
        let membersCount = List.length(state.members)
        let quorumReached = (votesTotal * 100 / membersCount) >= state.quorum
        require(quorumReached, "Quorum not reached")

        // Execute proposal based on its type
        if(proposal.proposalType == "addMember" && !proposal.isExecuted)
            _addMember(proposal.target)
        elif(proposal.proposalType == "removeMember" && !proposal.isExecuted)
            _removeMember(proposal.target)
        elif(proposal.proposalType == "setQuorum" && !proposal.isExecuted)
            _setQuorum(proposal.value)
        elif(proposal.proposalType == "setVotingTime" && !proposal.isExecuted)
            _setVotingTime(proposal.value)
        
        let executedProposal = proposal{isExecuted = true}
        put(state{proposals[proposalId] = executedProposal})
        let activities : userActivities = Map.lookup_default(Call.caller, state.activities, {address = Call.caller, proposalsCreated = 0, proposalsExecuted = 0, voteCasted = 0})
        put(state{activities[Call.caller] = activities{proposalsCreated = activities.proposalsExecuted + 1}})
        executedProposal

    /**
     * @dev Internal function to add a new member to the DAO.
     * @param newMember The address of the new member.
     */
    stateful function _addMember(newMember: address) = 
        if(!List.contains(newMember, state.members))
            put(state{members = newMember :: state.members})

    /**
     * @dev Internal function to remove a member from the DAO.
     * @param memberToRemove The address of the member to remove.
     */
    stateful function _removeMember(memberToRemove: address) = 
        let filteredMembers = List.filter((m) => m != memberToRemove, state.members)
        put(state{members = filteredMembers})

    /**
     * @dev Internal function to set a new quorum percentage for the DAO.
     * @param newQuorum The new quorum percentage.
     */
    stateful function _setQuorum(newQuorum: int) = 
        if(newQuorum > 0 && newQuorum =< 100)
            put(state{quorum = newQuorum})
        else
            abort("Invalid quorum value. Must be between 1 and 100.")

    /**
     * @dev Internal function to set a new voting time for proposals in the DAO.
     * @param newVotingTime The new duration of the voting period.
     */
    stateful function _setVotingTime(newVotingTime: int) = 
        if(newVotingTime > 0)
            put(state{votingTime = newVotingTime})
        else
            abort("Invalid voting time. Must be greater than 0.")


